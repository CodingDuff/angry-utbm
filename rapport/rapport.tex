\documentclass[a4paper,12pt]{report}

\usepackage{xltxtra} % charge aussi fontspec et xunicode, nécessaires...
\usepackage[frenchb]{babel}
\usepackage[top=2cm, bottom=2cm, left=3cm, right=3cm]{geometry}
\usepackage{url}
\usepackage{hyperref}
\usepackage{amsmath} % oh oui des maths
\usepackage{minted}
\usepackage{eurosym} %utilisation du signe euro
\usepackage{graphicx} %utilisation d'images
\usepackage{fancyhdr} %des en-têtes qui poutrent
\usepackage{titlesec}
\usepackage{upgreek} % lettres grecques
\usepackage{array}
\usepackage[table]{xcolor}
\usepackage[final]{pdfpages}

\usepackage{color} % on en a besoin pour utiliser les couleurs
\definecolor{grey}{rgb}{0.7, 0.7, 0.7}
\definecolor{blue}{rgb}{0.46,0.56,0.68}
\definecolor{red}{rgb}{0.509,0.145,0.114}
\definecolor{orange}{rgb}{1,0.4,0}

\usemintedstyle{tango}

\hypersetup{
     colorlinks=true, %colorise les liens
     breaklinks=true, %permet le retour à la ligne dans les liens trop longs
     urlcolor= blue,  %couleur des hyperliens
     linkcolor= black, %couleur des liens internes
     bookmarksopen=true,            %si les signets Acrobat sont créés,
                                    %les afficher complètement.
     pdftitle={LO43 : Rapport de projet}, %informations apparaissant dans
     pdfauthor={Loïs Aubree, Lucie Boutou, Benjamin GUILLET, Théophile Madet},     %dans les informations du document
     pdfsubject={Rapport de projet LO43},          %sous Acrobat.
     xetex
}

%%%% begin macro allowing marging changed some times :) %%%%
\newenvironment{changemargin}[2]{\begin{list}{}{%
\setlength{\topsep}{0pt}%
\setlength{\leftmargin}{0pt}%
\setlength{\rightmargin}{0pt}%
\setlength{\listparindent}{\parindent}%
\setlength{\itemindent}{\parindent}%
\setlength{\parsep}{0pt plus 1pt}%
\addtolength{\leftmargin}{#1}%
\addtolength{\rightmargin}{#2}%
}\item }{\end{list}}
%%%% end macro %%%%

%\pagestyle{fancyplain}
\pagestyle{fancy}
\fancyhf{}

% Avoir des subsubsection avec des lettres
%\renewcommand{\thesubsubsection}{\thesubsection .\alph{subsubsection}}
\renewcommand{\subsubsectionmark}[1]{\markright{#1}}

\fancyhead[L]{LO43 - A11 - Projet}
\fancyhead[R]{\textsc{Aubree} - \textsc{Boutou}- \textsc{Guillet} - \textsc{Madet}}
\fancyfoot[R]{\thepage}

\renewcommand{\emph}{\textbf}
\newcolumntype{M}[1]{>{\raggedright}m{#1}}

\input{garde}

\begin{document}

\garde{Loïs Aubree - Lucie Boutou\\Benjamin Guillet - Théophile Madet} % Authors
{\textbf{Projet de LO43}} % Title
{Réalisation d'un jeu AngryBirds-like} % Sub-title
{Rapport de projet} % Sub-sub-title
{Automne 2011} % Date
{} % Logo
{} % Note bas de page

\tableofcontents
\chapter{Présentation du projet}
\paragraph{}Nous avions ce semestre en LO43 la possibilité de développer un jeu ludique similaire à Angry Birds.

\paragraph{}Dans notre version, le joueur a à sa disposition un ensemble d'oiseaux \guillemotleft en colère\guillemotright~, et doit tuer les ennemis à l'aide d'oeufs pondus en vol. Les oiseaux peuvent également se sacrifier comme dans Angry Birds en réalisant une \guillemotleft attaque suicide\guillemotright~ et tuer les ennemis avec leur propre corps.

\paragraph{}Le joueur a au départ entre 3 à 5 oiseaux, selon la difficulté du niveau. Chaque type d'oiseaux possède des capacités de ponte (nombres d'oeufs) et des possibilités physiques qui lui sont particulières. Le score du joueur est calculé d'après son nombre d'oiseaux restants à la fin du niveau. Celui-ci est fini quand tous les ennemis sont morts.

\paragraph{}Le jeu est organisé en suivant des difficultés qui vont de facile à extrême, et chacune d'elle possède un nombre défini de niveaux. Seul le niveau 1 de chaque difficulté est au départ disponible, les niveaux suivants sont débloqués au fur et à mesure de la progression du joueur. Ce dernier ne peut accéder au niveau suivant qu'en ayant validé le précédent.
 

\chapter{Organisation et répartition du travail}
\paragraph{}Notre groupe était composé de quatre personnes, nous avons régulièrement organisé des réunions chez les uns et les autres pour avancer le projet et faire le point.

\paragraph{}La partie spécification UML a été faîte une première fois tous ensemble afin de se mettre d'accord sur une base de départ puis a évolué pour mieux coller au cahier des charges : respect du pattern MVC, utilisation des threads et du polymorphisme etc.

\paragraph{}Nous avons utilisé Eclipse, Skype et un dépot GitHub pour la synchronisation et la gestion des versions. GitHub possède également un suivi des fonctionnalités à ajouter ou à corriger. Ce qui a permit à chacun de travailler les classes et fonctionnalités nécessaires qui lui plaisaient.

\paragraph{}Globalement on peut dire que le travail s'est réparti ainsi :
\begin{itemize}
\item Benjamin  : base du projet (respect du pattern MVC), gestion du joueur ;
\item Loïs : collisions et envoi des oiseaux ;
\item Lucie: décors et menus ;
\item Théophile : gestion des sauvegardes, collisions.
\end{itemize}

\paragraph{}Mais tout le monde a par moment débordé sur le \guillemotleft secteur\guillemotright~ des autres pour corriger un bug ou améliorer une fonctionnalité. Rien n'était figé.

\chapter{Spécification}
\section{Diagramme de classes}
\section{Diagramme de séquences}

\chapter{Conception et prise en main}

\section{Gestion du menu}
\paragraph{}La gestion du menu s’effectue au travers de 6 panneaux différents : 
\begin{itemize}
\item MenuHomeView, panneau d’accueil au lancement du jeu.
\item MenuNewView, panneau de création d’une nouvelle partie.
\item MenuLoadView, panneau de chargement d’une partie.
\item MenuControlsView, panneau d’informations sur les contrôles du jeu.
\item MenuDifficultyView, panneau de choix de la difficulté du jeu.
\item MenuLevelView, panneau de choix du niveau.
\end{itemize}

\paragraph{}Chaque panneau est implémenté dans une classe propre à ses caractéristiques héritant de la classe GameViewMenu qui comporte les caractéristiques communes à tous les panneaux telle que le background du Menu.

\paragraph{}La classe GameViewMenu hérite elle-même de la classe JLayeredPane, qui permet d’indiquer aux éléments placés sur le panneau un index de position en profondeur, ce qui nous permet notamment de placer nos boutons par-dessus notre background.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.5]{images/navigationmenu.png} 
\end{center}
\caption{Navigation dans le menu}
\label{Navigation dans le menu}
\end{figure}

\paragraph{}La navigation dans le menu se fait au travers des différents boutons avec la souris, et pour le retour en arrière nous avons mis en place un contrôle supplémentaire par le clavier au moyen de la touche \guillemotleft échap \guillemotright(équivalent au retour en arrière avec le bouton \guillemotleft retour \guillemotright à la souris).
\paragraph{}Il y a alors détection du panneau sur lequel on se trouve afin de charger le panneau \guillemotleft précédent \guillemotright correspondant. 
\paragraph{}Pour le cas du panneau de choix de difficulté, l’accès au panneau a pu être réalisé depuis le panneau de création d’une nouvelle partie ou depuis le chargement d’une partie. C’est pourquoi une variable a été implémentée (parentPanel) afin de garder en mémoire depuis quel panneau a été fait le dernier accès au panneau de choix de difficulté.


\section{Gestion des niveaux}
\paragraph{}La création d’un niveau du jeu s’appuie sur la lecture d’un fichier texte qui doit contenir les informations suivantes :
\begin{itemize}
\item les oiseaux disponibles pour réaliser le niveau.
\item la position des différents blocs représentant le décor.
\item la position des cochons dans ce décor.
\end{itemize}

\paragraph{}On retrouve en tête du fichier la liste des oiseaux. Un retour à la ligne est effectué après chaque oiseau disponible dans le niveau afin de faciliter la lecture du fichier. De plus les oiseaux sont indiqués dans le même ordre que leur ordre d’apparition dans le niveau.
\paragraph{}Un test d’égalité a lieu entre la chaîne de caractère contenue dans la ligne et les différents types d’oiseaux, afin de créer l’oiseau correspondant et de l’ajouter à un ArrayList d’entités.
\paragraph{}Lors de la lecture du fichier texte, la rencontre du mot \guillemotleft Map \guillemotright permet au programme de savoir que la liste des oiseaux disponibles pour le niveau est complète et que la suite du fichier contient la carte représentant le niveau.
\paragraph{}Il s’agit de lignes de texte de taille égale contenant différents caractères qui seront implémentés dans un tableau de deux dimensions (chaque ligne du fichier texte correspond à une ligne du tableau 2D).
\paragraph{}Le tableau à une taille adaptable aux dimensions de notre fenêtre et de nos éléments de décor. Chaque élément du décor a une image correspondante de 26*26 pixels, et pour correspondre ici à une fenêtre de taille 1200*600 pixels, une ligne du tableau contient 47 éléments et une colonne en contient 22.
\paragraph{}Chaque caractère correspond à un élément différent sur le décor :
\begin{itemize}
\item le \guillemotleft 0 \guillemotright indique que rien ne se trouve à cet endroit de la carte.
\item le \guillemotleft 1 \guillemotright indique qu’il y a un bloc d’herbe à cet endroit de la carte.
\item le \guillemotleft 2 \guillemotright indique qu’il y a un bloc de pierre à cet endroit de la carte.
\item le \guillemotleft 3 \guillemotright indique la position de départ d’un cochon ennemi.
\end{itemize}
\paragraph{}Une lecture du tableau est ensuite réalisée et à chaque \guillemotleft 1 \guillemotright, \guillemotleft 2 \guillemotright, ou \guillemotleft 3 \guillemotright rencontré, on créé l'entité correspondante (cochon, bloc d'herbe ou bloc de pierre). L'entité est créé via un constructeur prenant en paramètre sa position x (calculée à l'aide de l'index des colonnes du tableau et de la taille de l'image correspondante à l'entité) et sa position y (calculée à l'aide de l'index des lignes du tableau et de la taille de l'image correspondante à l'entité).

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.4]{images/lvl01image.png} 
\end{center}
\caption{Screenshot niveau 1}
\label{Screenshot niveau 1}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=1]{images/lvl01texte.png} 
\end{center}
\caption{Fichier texte niveau 1}
\label{Fichier texte niveau 1}
\end{figure}

\paragraph{}La figure 4.2 est le fichier texte correspondant au niveau représenté en figure 4.1. On remarque que la dernière ligne ne comportant que des \guillemotleft 1 \guillemotright concorde bien à une ligne de blocs d'herbe sur la partie basse de notre fenêtre. De même les \guillemotleft 2 \guillemotright concordent à des blocs de pierres et les \guillemotleft 3 \guillemotright à des cochons.

\paragraph{}On aperçoit dans le coin en haut à droite de la figure 4.1 les oiseaux disponibles dans le niveau, coïncidant aux premières lignes du fichier texte de la figure 4.2.

\paragraph{}D'une manière générale on remarque que la création de nouveaux niveaux ou la modification de niveaux existants est relativement simple.

\section{Gestion des collisions}

\paragraph{}La gestion des collisions et les événements qui en découlent sont effectués dans la fonction updateEntity().

\paragraph{}Chaque entité créée possède ce qu'on appelle une hitBox ; c'est-à-dire que chaque objet graphique est englobé d'un rectangle de collisions. 

\paragraph{}Pour assurer le traitement des collisions, on parcourt la liste des entités du GameModel. Ensuite, suivant l'entité courante traitée, on gère ses collisions avec les autres entités en testant si sa hitBox est en intersection avec la hitBox des autres.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.4]{images/lvl01hitbox.png} 
\end{center}
\caption{Niveau 1 avec hitBoxes visibles}
\label{Niveau 1 avec hitBoxes visibles}
\end{figure}

\paragraph{}Si la collision d'un élément avec un autre doit entraîner la suppression d'un des deux objets, le programme ajoute celui ou ceux-ci dans une liste d'Entity (toRemove). Celle-ci est parcourue à son tour en fin de fonction pour effectuer la suppression des entités dans le GameModel. Cela permet de supprimer toutes les entités concernées au même niveau dans l'algorithme et aussi de s'assurer que tous les traitements sur les entités ont été réaliser avant d'en supprimer.

\paragraph{}Les différentes collisions gérées sont les suivantes :

\subparagraph{Collision des œufs :}
~\\
\begin{itemize}
\item[•] avec les cochons : lorsque la collision est détectée, on ajoute le cochon et l'œuf courant dans la liste des entités à supprimer.
\item[•] avec les blocs de pierre : la collision provoque l'ajout des entités bloc de pierre et œuf concernées dans la liste des entités à supprimer.
\item[•] avec les blocs d'herbe : la collision provoque l'ajout simple de l’œuf courant dans la liste toRemove. Le bloc d'herbe étant indestructible.
\end{itemize}

\subparagraph{Collision des cochons :}
~\\
\begin{itemize}
\item[•] avec les blocs de pierre : 
\begin{itemize}
\item[-]gestion de la collision : la gestion de la collision est différente, ici, puisqu'elle ne se fait pas sur le rectangle de collision du bloc de pierre avec celui du cochon. En effet, les cochons peuvent se déplacer librement sur les blocs de pierre, mais, lorsqu'ils percutent un bloc de pierre par le côté, la collision doit provoquer le changement de direction dans le déplacement du cochon. On doit être en mesure de tester avec quelle arête de la hitBox du bloc de pierre, la hitBox du cochon est en intersection.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.4]{images/collisionscochons.png} 
\end{center}
\caption{Différentes collisions des cochons}
\label{Différentes collisions des cochons}
\end{figure}

\item[-]événement : lorsque le cochon touche une des arêtes gauche ou droite d'un bloc de pierre, le cochon change de direction de déplacement (gauche ou droite) ; lorsque le cochon n'est pas en collision avec une seule des arêtes supérieures d'un des blocs de pierre (c'est-à-dire que le cochon se déplace sur aucun des blocs de pierre) il tombe, La chute du cochon se fait jusqu'à ce qu'il rencontre l'arête supérieure d'un des blocs (de pierre ou d'herbe) ; la gestion avec l’arête inférieur des blocs n'a aucun intérêt ici.
\end{itemize}
\item[•] avec les cochons : lorsque deux cochons se rencontrent, cela provoque le changement de direction des deux cochons concernés.
\end{itemize}

\subparagraph{Collision des oiseaux :}
~\\
\begin{itemize}
\item[•] avec les blocs de pierres : lorsqu'un oiseau entre en collision avec la hitBox d'un bloc de pierre, cela provoque l'ajout de ces deux entités dans la liste des suppressions. On peut une nouvelle fois justifier ici le choix du traitement des suppressions en fin de fonction car la hitBox des oiseaux est assez grande pour entrer en collision avec plusieurs blocs à la fois. Seulement, si la suppression de l'oiseau était faite directement avec la détection de la collision pour le premier bloc, les autres blocs aussi en collision ne seraient pas supprimés car ils seraient non testés.
\item[•] avec les cochons : la collision d'un oiseau et d'un cochon provoque l'ajout de ces deux entités dans la liste des suppressions.
\end{itemize}

\paragraph{}Dans la fonction updateEntity(), il est aussi géré la visibilité des entités lorsque la position de celles-ci dépasse les bords de la fenêtre (gauche, droite ou bas). L'élément concerné est ajouté dans la liste des suppressions.

\section{Gestion des oiseaux}

\paragraph{}Tous les oiseaux héritent de la classe abstraite Bird. 

\paragraph{Création de l'oiseau courant :}

\paragraph{}L'oiseau courant, celui qui est positionné au lance pierre est le premier oiseau trouvé en parcourant la liste des entités dans l'ordre.

\paragraph{}Pour définir un oiseau comme courant, on parcoure la liste des entités et lorsque la première instance d'un Bird est détectée, le pointeur CurrentBird est placé sur cette instance.

\paragraph{Vie de l'oiseau :}

\paragraph{}Lorsqu'un oiseau est courant, il possède deux phases : une première de préparation au vol et une seconde de vol.\\

\begin{itemize}
\item[-]Préparation au vol : l'oiseau est positionné sur le lance-pierre, le joueur a alors la possibilité de tendre l’élastique du lance-pierre pour  déterminer la vitesse initiale et l'angle initial avec lequel le lancer de l'oiseau est effectué. Pour cela, le joueur doit cliquer sur l'oiseau du lance pierre puis effectuer un glissé tout en gardant le bouton de la souris enfoncé. Lorsque le joueur lâche le bouton de la souris, l'oiseau passe en mode vol (le booléen isFlying passe à true).
\item[-]Phase de vol : l'oiseau en vol est soumis à la formule d’accélération, une accélération de 9.81 (simulant la gravité) est appliquée en Y. La position de l'oiseau est modifiée en fonction du temps, de l'angle initial imposé et de la vitesse initiale imposée. En vol, le joueur a la possibilité de lâcher des œufs (dans la limite du nombre d’œufs attribués : eggLeft). Le joueur peut aussi, si le type d'oiseau le permet (pigeon ou colibri) effectué un vol stationnaire. A ce moment là, l'oiseau arrêtera son vol puis le joueur aura la possibilité de reprendre le cours du vol  dans la limite du temps de vol restant pour l'oiseau.
\end{itemize}

\paragraph{Mort de l'oiseau courant :}

\paragraph{}Lorsque l'oiseau courant meurt (collision avec un bloc, collision avec un cochon, plus visible dans la fenêtre ou temps de vol terminé), l'oiseau est ajouté dans la liste des suppressions de la fonction updateEntity() puis il est supprimé. La liste des entités est alors à nouveau parcourue pour déterminer le nouvel oiseau courant.

\section{Gestion de la victoire ou défaite d'un niveau}

\paragraph{}Chaque niveau possède un nombre d’ennemis (cochons) définit. Le jeu est gagné lorsque tous les cochons du niveau ont été tués (supprimer de la liste des entités).
\paragraph{}Le test de victoire est effectué dans la fonction updateEntity(). Lorsqu'on parcourt la liste des entités, on effectue la mise à jour du comportement des cochons, or si la liste des entités ne comporte plus aucune instance de cochon alors le niveau est terminé. 
\paragraph{}Si le niveau est terminé, le programme entre dans la fonction win() qui se chargera d'effectuer tous les traitements de la victoire.
\paragraph{}De la même façon que pour la gestion de la victoire, l'événement de défaite est provoqué dans la fonction updateEntity(). Mais, cette fois, le test n'est pas effectué sur les instances de cochons mais sur les instances des oiseaux dans la liste des entités. Lorsqu'il n'y a plus d'oiseaux dans la liste, la fonction lose() est appelée.
\paragraph{}Dans ce cas il est important de faire les traitements sur les cochons en premier, pour qu'il n'y ait pas d'appel à la fonction lose() lorsqu'il n'y a plus de d'oiseaux ni de cochons (l'appel à la fonction win() passera donc en priorité).

\chapter{Bilan}
\section{Conclusion}
\paragraph{}Ce projet était très intéressant et motivant. Son côté ludique nous a permis d'apprendre le java avec une vraie motivation et une bonne ambiance. Un groupe important comme le notre nécessite une bonne communication afin que chacun sache le travail à accomplir et éviter les répétitions. Heureusement aujourd'hui nous avons de nombreux outils à notre disposition pour nous faciliter la tâche, en plus des classiques réunions ou e-mails.

\section{Améliorations possibles}
\paragraph{}Un projet comme celui-ci est toujours perfectible, voici quelques-unes des améliorations qui nous viennent en tête et que nous aurions bien voulu implémenter :
\begin{itemize}
\item Il serait facile d'ajouter une musique d'ambiance, des bruits lors des collisions ou lorsque l'on gagne ou perds ;
\item On pourrait afficher le meilleur score du joueur actuel sous chaque niveaux ;
\item Les ennemis pourraient gérer la gravité, c'est à dire s'ils sont placés sur un bloc en hauteur, descendre jusqu'en bas lors de la destruction de ce bloc.
\end{itemize}
\end{document}
